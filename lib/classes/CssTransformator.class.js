"use strict";const _=require("lodash"),debug=require("debug")("Crittr CSSTransformator"),log=require("signale"),merge=require("deepmerge"),css=require("css"),Rule=require("./Rule.class");class CssTransformator{constructor(e){e=e||{},this.options={silent:!0,source:null},this.options=merge(this.options,e);this._TYPES_TO_REMOVE=["comment"],this._TYPES_TO_KEEP=["charset","font-face"];const s=[":before",":after",":visited",":first-letter",":first-line"].map(e=>":?"+e).join("|");this._PSUEDO_SELECTOR_REGEXP=new RegExp(s,"g")}getAst(e){let s=null;try{debug("getAst - Try parsing css to ast ..."),s=css.parse(e,{silent:this.options.silent,source:this.options.source}),debug("getAst - Css successfully parsed to ast ...")}catch(e){log.error(e)}return s}getCssFromAst(e){return debug("getCssFromAst - Create css string out of AST"),css.stringify(e,{indent:"  ",compress:!1,sourcemap:!0,inputSourcemaps:!0})}filterSelector(e,s){if(!Array.isArray(s))return log.warn("removeSelectors have to be an array to be processed"),!1;let t=e;e.stylesheet?t=e.stylesheet.rules:e.rules&&(t=e.rules);const r=(e,s)=>s-e,l=[];for(const e in t)if(t.hasOwnProperty(e)){const i=t[e];if(Rule.isMediaRule(i))this.filterSelector(i,s);else{const t=i.selectors,o=[];for(let r in t)if(t.hasOwnProperty(r)){const i=t[r];s.includes(i)&&(t.length>1?o.push(r):l.push(e))}o.sort(r);for(let e of o)t.splice(e,1)}}l.sort(r);for(let e of l)t.splice(e,1);return e}filterByMap(e,s){let t=JSON.parse(JSON.stringify(e)),r=JSON.parse(JSON.stringify(e));const l=t.stylesheet,i=r.stylesheet;let o=[];const u=new Map,n=(e,s,t)=>{s=s||"";const r=Rule.generateRuleKey(e,s);if(t.has(r)){const s=t.get(r);return e.selectors.filter(e=>s.selectors.includes(e))}return[]};let c=l.rules.filter(e=>!this._TYPES_TO_REMOVE.includes(e.type));c=(c=c.map((e,t,r)=>{if("media"===e.type)e.rules&&(e.rules=e.rules.map(t=>{const r=Rule.generateRuleKey(t,e.media);return t.selectors=n(t,e.media,s),u.set(r,t.selectors),t}).filter(e=>void 0!==e.selectors&&e.selectors.length>0),0===e.rules.length&&o.push(e));else if("rule"===e.type){const t=Rule.generateRuleKey(e);e.selectors=n(e,"",s),u.set(t,e.selectors),0===e.selectors.length&&o.push(e)}else debug("Unprocessed rule type! >> "+e.type);return e})).filter(e=>!o.includes(e)),o=[];let a=i.rules.map(e=>{const s="media"===e.type?e.media:"";if("media"===e.type)e.rules&&(e.rules=e.rules.map(e=>{const t=Rule.generateRuleKey(e,s);if(u.has(t)){const s=u.get(t);e.selectors=e.selectors.filter(e=>!s.includes(e))}return e}).filter(e=>void 0!==e.selectors&&e.selectors.length>0),0===e.rules.length&&o.push(e));else if("rule"===e.type){const t=Rule.generateRuleKey(e,s);if(u.has(t)){const s=u.get(t);e.selectors=e.selectors.filter(e=>!s.includes(e))}0===e.selectors.length&&o.push(e)}return e});return a=a.filter(e=>!(o.includes(e)||this._TYPES_TO_KEEP.includes(e.type))),l.rules=c,i.rules=a,[t,r]}merge(e,s){return new Promise((t,r)=>{if(debug("merge - Try to merge into targetAst..."),e.type&&"stylesheet"===e.type&&e.stylesheet&&Array.isArray(e.stylesheet.rules))try{let l=s.stylesheet.rules,i=e.stylesheet.rules;for(let e of l)this.mergeRule(e,i);debug("merge - Successfully merged into targetAst!"),t(e)}catch(e){debug("merge - general error occured."),r(e)}else debug("merge - ERROR because of missing properties!"),r(new Error("AST Merge failed due to missing properties"))})}mergeRule(e,s){if(Rule.isMediaRule(e))this.mergeMediaRule(e,s);else if(s.length>0){let t=!1;for(let r of s)if(Rule.isSameRuleType(r,e)&&Rule.isRuleDuplicate(r,e,["position"])){t=!0;break}t||s.push(e)}else s.push(e)}mergeMediaRule(e,s){const t=e.media,r=e.rules;let l=[],i=!0;for(let e of s)if(Rule.isMediaRule(e)&&Rule.isMatchingMediaRuleSelector(t,e.media)){l=e.rules,i=!1;break}if(i)s.push(e);else for(let e of r)this.mergeRule(e,l)}}module.exports=CssTransformator;